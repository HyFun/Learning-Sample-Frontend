<!--
 * @Author       : HyFun
 * @Date         : 2021-07-16 17:20:35
 * @Description  : Set
 * @LastEditors  : HyFun
 * @LastEditTime : 2021-07-16 17:43:58
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Set</title>
  </head>
  <body></body>
</html>
<script>
  function divider() {
    console.log(`-----------------`)
  }
  /**
   * 1. Set.prototype.add(value)
   * 在Set对象尾部添加一个元素
   *
   * 返回：set对象
   */
  {
    const set = new Set()
    set.add(1)
    set.add(1)
    console.log(set.add(2))
  }
  divider()

  /**
   * 2. Set.prototype.clear()
   * 移除Set对象内的所有元素。
   *
   * 返回：无
   */
  {
    const set = new Set()
    set.add(1)
    console.log(`清空之前`, set)
    set.clear()
    console.log(`清空之后`, set)
  }
  divider()

  /**
   * 3. Set.prototype.delete(value)
   * 移除Set中与这个值相等的元素
   *
   * 返回：boolean  true 删除成功  false 删除失败
   */
  {
    const set = new Set()
    set.add('1')
    set.add('2')
    console.log(`删除之前`, set)
    console.log(`删除`, set.delete(1)) // false
    console.log(`删除`, set.delete('1')) // true
    console.log(`删除之后`, set)
  }
  divider()

  /**
   * 4. Set.prototype.entries()
   * 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的
   */
  {
    const set = new Set()
    set.add('张三')
    set.add('李四')
    set.add('王五')
    console.log(set)
    const iterators = set.entries()
    for (const iterator of iterators) {
      console.log(iterator)
    }
  }
  divider()

  /**
   * 5. Set.prototype.forEach(callbackFn[, thisArg])
   * 按照插入顺序，为Set对象中的每一个值调用一次callBackFn
   */
  {
    const set = new Set()
    set.add('张三')
    set.add('李四')
    set.add('王五')
    set.forEach((v) => {
      console.log(v)
    })
  }
  divider()

  /**
   * 6. Set.prototype.has(value)
   * 判断是否有这个值
   */
  {
    const set = new Set()
    set.add('张三')
    set.add('李四')
    set.add('王五')
    console.log(set.has('123')) // false
    console.log(set.has('张三')) // true
  }
  divider()

  /**
   * 7. Set.prototype.keys() (en-US)
   * 返回一个新的迭代器对象
   */
  {
    const set = new Set()
    set.add('张三')
    set.add('李四')
    set.add('王五')
    const iterators = set.keys()
    for (const iterator of iterators) {
      console.log(iterator)
    }
  }
  divider()

  /**
   * 8. Set.prototype.values()
   * 返回一个新的迭代器对象
   */
  {
    const set = new Set()
    set.add('张三')
    set.add('李四')
    set.add('王五')
    const iterators = set.values()
    for (const iterator of iterators) {
      console.log(iterator)
    }
  }
  divider()

  /**
   * 9. Set.prototype.size
   * 属性，返回个数
   */
  {
    const set = new Set()
    set.add('张三')
    set.add('李四')
    set.add('王五')
    console.log(set.size) // 3
  }
  divider()

  /**
   * 10. 构造函数
   */
  {
    // 无参
    const set = new Set()
    // 有参 接收一个 实现iterator接口的参数
    const set1 = new Set([1, 2, 3, 3, 3, 4, 4, 5, 5])
    console.log(set1)
  }
</script>
